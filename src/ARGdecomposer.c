/*
 * ARGdecomposer.c
 *
 *  Created on: 17.11.2016
 *      Author: heine
 *
 *  Written by Kari Heine.
 *
 * Copyright (C) 2016, Kari Heine, Maria De Iorio, Alex Beskos, Ajay Jasra,
 * David Balding. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *   3. The names of its contributors may not be used to endorse or promote
 *      products derived from this software without specific prior written
 *      permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 */

#include <assert.h>
#include <stdbool.h>
#include "ARGdecomposer.h"
#include "utils.h"
#include "sorting.h"

int decomposeARG(struct ShrubARG arg, struct Tree *tree_path, short **opers,
		struct Data data, short n_nodes, int *op_sites) {

	short *times;
	short **tree_times, **trees;
	short n_nodes_reduced, n_leaves = arg.n_seq;

	/* n_nodes_reduced denotes the number of branch nodes (i.e. not leaves) that
	 * remain after cleaning up the local trees from nodes with only one child.
	 * Because we know that the resulting trees are full binary trees, we know
	 * that the number of nodes must be 2*n_leaves-1, from which the value of
	 * n_nodes_reduced can be deduced to be as follows:
	 * */
	n_nodes_reduced = n_leaves - 1;

	trees = malloc(sizeof(short *) * arg.n_rec);
	for (int i = 0; i < arg.n_rec; i++)
		trees[i] = malloc(sizeof(short) * 3 * n_nodes);

	extractRecombinationSites(arg, data, op_sites);
	extractTreeSequence(arg, data, trees, op_sites);
	extractOperations(arg, opers, op_sites);
	intInsert(op_sites, 1, 0, arg.n_rec + 1);

	times = malloc(sizeof(short) * arg.n_nodes);
	fillShortArray(times, -1, 1, arg.n_nodes, 1);
	createARGtimes(arg, times);

	tree_times = malloc(sizeof(short *) * arg.n_rec);
	for (int i = 0; i < arg.n_rec; i++) {
		// initialise tree times by copying them from the arg node times
		tree_times[i] = malloc(sizeof(short) * n_nodes);
		for (int j = 0; j < n_nodes; j++)
			tree_times[i][j] = times[j + n_leaves];
	}
	free(times);

	/* Check that all consecutive trees are unique */
	for (int i = 0; i < arg.n_rec - 1; i++)
		if (compareTreeMtxs(trees[i], trees[i + 1], n_nodes, n_nodes) != 0)
			return -1;

	/* After the extraction of trees from the ARG generated by SHRUB, trees are
	 * not binary; they may have nodes that have only one child. Trees are
	 * cleaned by removing such nodes resulting in a binary tree where each node
	 * has either 0 or 2 children. */
	for (int i = 0; i < arg.n_rec; i++) {
		binarize(trees[i], opers[i], n_nodes, n_leaves, tree_times[i]);
		tree_path[i].C = malloc(sizeof(short) * n_nodes_reduced * 2);
		shortArrayCopy(tree_path[i].C, trees[i], n_nodes_reduced, 2, n_nodes);
		tree_path[i].times = malloc(sizeof(double) * n_nodes_reduced);
		tree_path[i].n_nodes = 2 * (n_nodes_reduced + 1) - 1;

		for (int j = 0; j < n_nodes_reduced; j++)
			tree_path[i].times[j] = (double) tree_times[i][j];

		// ensure that the nodes are in correct time order
		timeSorting(tree_path[i], opers[i]);
	}

//	printf("Binarization completed\n");

	/* Create the last tree in the sequence */
	tree_path[arg.n_rec] = createTree(n_leaves);
	copyTree(&tree_path[arg.n_rec], tree_path[arg.n_rec - 1]);
	SPR(tree_path[arg.n_rec], opers[arg.n_rec - 1]);
	timeSorting(tree_path[arg.n_rec], NULL);

	for (int i = 0; i < arg.n_rec; i++) {
		free(trees[i]);
		free(tree_times[i]);
	}
	free(tree_times);
	free(trees);
	return 0;
}

void binarize(short *tree, short *oper, short n_nodes, short n_leaves, short *times) {

	short *parent_rows;
	short n_childs, ch[2], kill_count = 0, cont = 1, n_nodes_new = n_nodes;

	parent_rows = malloc(sizeof(short) * 100);
//	parent_rows = malloc(sizeof(short) * 2);

	while (cont == 1) {
		for (int i = 0; i < n_nodes_new; i++) { // iterate over the remaining nodes

			n_childs = countChildren(tree, i, n_nodes, ch);

			if (n_childs == 1) { // only one child

				findParentRows(tree, n_nodes, i + n_leaves, parent_rows);

				// replace i as the child of i's parent by the only child of i
				if (jumpGeneration(tree, parent_rows, i + n_leaves, ch, n_nodes) != 0)
					printf("ERROR: One of the parents children should be the child itself.");

				// if prune or regraft node is the removed node, change the corresponding operation
				// entry equal to the unique child node
				if (oper[0] == i + n_leaves)
					oper[0] = ch[0];
				else if (oper[1] == i + n_leaves)
					oper[1] = ch[0];

				// remove the single child node
				shortRemoveRow(tree, i, n_nodes, 2);
				shortRemoveRow(times, i, n_nodes, 1);

				kill_count++;
				n_nodes_new--;

				// reduce the node indices of all nodes greater than the removed node
				shiftIndices(tree, oper, n_nodes_new, i + n_leaves, n_nodes);

				cont = 1;
				break;
			}
			cont = 0;
		}
	}
	free(parent_rows);
}

void shiftIndices(short *tree, short *oper, short n_nodes, short i, short n_alloc) {
	// Shift node indices in the graph matrix
	for (int j = 0; j < n_nodes; j++) {
		if (tree[j] > i)
			tree[j]--;
		if (tree[j + n_alloc] > i)
			tree[j + n_alloc]--;
	}
	// Shift the node indices in the operation array
	if (oper[0] > i)
		oper[0]--;
	if (oper[1] > i)
		oper[1]--;
}

int jumpGeneration(short *tree, short *parent_rows, short i, short *ch, short n_nodes) {

	if (tree[parent_rows[0]] == i)
		tree[parent_rows[0]] = ch[0];
	else if (tree[parent_rows[0] + n_nodes] == i)
		tree[parent_rows[0] + n_nodes] = ch[0];
	else
		return -1;

	return 0;
}

void extractRecombinationSites(struct ShrubARG arg, struct Data data, int *op_sites) {

	int *i_sort, *op_rows, *array;
	int n_op = 0, n_nodes = arg.n_nodes;

	array = malloc(sizeof(int) * arg.n_rec);
	i_sort = malloc(sizeof(int) * arg.n_rec);
	op_rows = malloc(sizeof(int) * arg.n_rec);

	/* Extract the recombination sites and sort them in the increasing order */
	for (int i = 0; i < n_nodes; i++)
		if (arg.C[i + 2 * n_nodes] > 0 && arg.C[i + 2 * n_nodes] < SHRT_MAX) {
			i_sort[n_op] = n_op;
			op_rows[n_op] = i;
			array[n_op++] = arg.C[i + 2 * n_nodes];
		}

	sortIntArray(i_sort, array, n_op);

	for (int i = 0; i < n_op; i++)
		op_sites[i] = data.segregating_sites[array[i_sort[i]]];

	/* Resolve situations where multiple recombinations occur at the same site. */
	resolveParallelRecombinations(op_sites, n_op, data);

	for (int i = 0; i < n_op; i++)
		arg.C[op_rows[i_sort[i]] + 2 * n_nodes] = op_sites[i];

	free(i_sort);
	free(array);
	free(op_rows);
}

void extractTreeSequence(struct ShrubARG arg, struct Data data, short **trees,
		int *op_sites) {

	int n_branch = arg.n_nodes - arg.n_seq;

	for (int i = 0; i < arg.n_rec; i++) {
		/* Copy ARG graph structure */
		for (int j = 0; j < 3 * n_branch; j++)
			trees[i][j] = arg.C[j + arg.n_seq
					+ ((int) floor((double) j / (double) n_branch)) * arg.n_seq];
		extractTree(trees[i], op_sites[i], arg.n_nodes, arg.n_seq);
	}
}

void extractTree(short *C, int site, short n_nodes, short n_leaves) {

	short *parents;
	int n_parents, j;
	short n_branch = n_nodes - n_leaves;
	parents = malloc(sizeof(short) * n_nodes);

	for (int i = 0; i < n_nodes; i++) {
		n_parents = findParentRows(C, n_branch, i, parents);
		if (n_parents > 1) {
			for (j = 0; j < n_parents; j++)
				if (C[parents[j] + 2 * n_branch] >= site)
					break;
			for (int k = 0; k < n_parents; k++)
				if (parents[k] != parents[j]) {
					if (C[parents[k]] == i)
						C[parents[k]] = -1;
					if (C[parents[k] + n_branch] == i)
						C[parents[k] + n_branch] = -1;
				}
		}
	}
	free(parents);
}

void extractOperations(struct ShrubARG arg, short **opers, int *op_sites) {

	short prune_node, regraft_node, n_leaves = arg.n_seq;
	int j;

	for (int i = 0; i < arg.n_rec; i++) {

		// Prune node is the child in the left column on the row with matching recombination site
		for (j = n_leaves; j < arg.n_nodes; j++)
			if (arg.C[j + 2 * arg.n_nodes] == op_sites[i])
				break;
		prune_node = arg.C[j];

		// pruning node is the right column child of the next parent
		// (next parent represents the node introduced by the recombination and thus its child is
		// the regrafting node
		for (j = n_leaves; j < arg.n_nodes; j++)
			if (arg.C[j] == prune_node && arg.C[j + 2 * arg.n_nodes] > op_sites[i])
				break;
		regraft_node = arg.C[j + arg.n_nodes];

		opers[i][0] = prune_node;
		opers[i][1] = regraft_node;
	}
}

/* This creates short integer times. The purpose of these time is only to provide order, so
 * double precision times are not needed.
 * */
void createARGtimes(struct ShrubARG arg, short *times) {

	short root = findRoot(arg.C, arg.n_nodes, arg.n_seq);
	setTime(arg.C, times, root, arg.n_nodes, arg.n_seq);

}

void setTime(short *C, short* times, short n, short n_nodes, short n_leaves) {

	short t_left, t_right;

	if (n < n_leaves) {
		// terminate recursion
		times[n] = 0;
	} else {

		// branch recursion to left
		t_left = times[C[n]];
		if (t_left < 0)
			setTime(C, times, C[n], n_nodes, n_leaves);

		// branch recursion to right
		t_right = times[C[n + n_nodes]];
		if (t_right < 0)
			setTime(C, times, C[n + n_nodes], n_nodes, n_leaves);

		// finish recursion step
		times[n] = shortMax(times, n_nodes, NULL) + 1;
	}
}

//void resolveParallelRecombinations(int *op_sites, int n_op) {
//	int j;
//	printIntArray(op_sites, n_op, 1, n_op);
//	getchar();
//	for (int i = 1; i < n_op; i++) {
//		for (j = n_op - i; j < n_op; j++)
//			if (op_sites[j] == op_sites[n_op - i - 1])
//				break;
//		while (j < n_op) {
//			op_sites[n_op - i - 1] -= 2;
//			for (j = n_op - i; j < n_op; j++)
//				if (op_sites[j] == op_sites[n_op - i - 1])
//					break;
//		}
//	}
//}

void resolveParallelRecombinations(int *op_sites, int n_op, struct Data data) {

	long *unique_sites;
	long is, ie;
	short *counts, cnt = 0, cnt2 = 0;
	int k;

	unique_sites = malloc(sizeof(long) * n_op);
	counts = malloc(sizeof(short) * n_op);

	/* unique operation sites and their histogram */
	unique_sites[cnt] = op_sites[cnt];
	counts[cnt] = 1;
	cnt++;
	for (int i = 1; i < n_op; i++) {

		if (op_sites[i] < op_sites[i - 1]) {
			printf("Sites should be an increasing sequence\n");
			assert(false);
		}

		if (op_sites[i] != op_sites[i - 1]) {
			unique_sites[cnt] = op_sites[i];
			counts[cnt] = 1;
			cnt++;
		} else {
			counts[cnt - 1]++;
		}
	}

	for (int i = 0; i < cnt; i++) {
		is = i == 0 ? 1 : unique_sites[i - 1];

		for (k = 0; k < data.n_sites; k++)
			if (data.segregating_sites[k] == unique_sites[i])
				is = k == 0 ? 1 : data.segregating_sites[k - 1];

		ie = unique_sites[i];

		if ((double) (ie - is) / (double) counts[i] < 1) {
			printf("Sites are too closely spaced (%ld %ld %hd). Exiting...",ie,is,counts[i]);
			assert(false);
		}

		for (int j = 0; j < counts[i]; j++)
			op_sites[cnt2++] = (int) (is
					+ (long) rint((double) (j + 1) * (double) (ie - is) / (double) counts[i]));
	}
	free(unique_sites);
	free(counts);
}

